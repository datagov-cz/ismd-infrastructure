name: 'Terraform Deployment'

on:
  # Triggered from other repositories
  repository_dispatch:
    types:
      - new-image-dev
      - new-image-test
      - new-image-prod

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    environment: |
      ${{ 
        github.event.action == 'new-image-prod' && 'prod' 
        || github.event.action == 'new-image-test' && 'test' 
        || 'dev' 
      }}
    
    defaults:
      run:
        working-directory: .
    
    steps:
    - name: Checkout
      uses: actions/checkout@v5
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.11.3'
    
    - name: Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Select Environment
      id: select-env
      run: |
        # Extract environment from the event type (new-image-dev, new-image-test, new-image-prod)
        EVENT_TYPE="${{ github.event.action }}"
        ENV="${EVENT_TYPE#new-image-}"
        echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV
        echo "STATE_KEY=$ENV/terraform.tfstate" >> $GITHUB_ENV
        
        # Extract image versions from payload if provided
        if [ "${{ github.event.client_payload.component }}" == "frontend" ] && [ ! -z "${{ github.event.client_payload.image_tag }}" ]; then
          echo "FRONTEND_IMAGE=${{ github.event.client_payload.image_tag }}" >> $GITHUB_ENV
          echo "Processing frontend image: ${{ github.event.client_payload.image_tag }}"
        fi
        
        if [ "${{ github.event.client_payload.component }}" == "backend" ] && [ ! -z "${{ github.event.client_payload.image_tag }}" ]; then
          echo "BACKEND_IMAGE=${{ github.event.client_payload.image_tag }}" >> $GITHUB_ENV
          echo "Processing backend image: ${{ github.event.client_payload.image_tag }}"
        fi
    
    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="key=${{ env.STATE_KEY }}"
    
    - name: Terraform Format
      run: terraform fmt -recursive
      continue-on-error: true
    
    - name: Create Variable File
      run: |
        # Create directory if it doesn't exist
        mkdir -p environments/${{ env.ENVIRONMENT }}
        
        # Set default location
        LOCATION="germanywestcentral"
        
        # Set resource group names based on environment
        SHARED_RG="ismd-shared-${{ env.ENVIRONMENT }}"
        VALIDATOR_RG="ismd-validator-${{ env.ENVIRONMENT }}"
        
        # Set image repositories based on environment
        FE_REPO="ghcr.io/datagov-cz/ismd-validator-frontend-${{ env.ENVIRONMENT }}"
        BE_REPO="ghcr.io/datagov-cz/ismd-validator-backend-${{ env.ENVIRONMENT }}"
        
        # Get image tags from environment or use defaults
        FE_TAG="${{ env.FRONTEND_IMAGE || 'latest' }}"
        BE_TAG="${{ env.BACKEND_IMAGE || 'latest' }}"
        
        # Create dynamic tfvars file
        cat > environments/${{ env.ENVIRONMENT }}/terraform.tfvars << EOF
        environment = "${{ env.ENVIRONMENT }}"
        location = "$LOCATION"
        shared_resource_group_name = "$SHARED_RG"
        validator_resource_group_name = "$VALIDATOR_RG"
        
        # Container images
        frontend_image = "$FE_REPO"
        frontend_image_tag = "$FE_TAG"
        backend_image = "$BE_REPO"
        backend_image_tag = "$BE_TAG"
        EOF
        
        # Show created file for debugging
        echo "Created variable file:"
        cat environments/${{ env.ENVIRONMENT }}/terraform.tfvars
    
    - name: Terraform Plan
      run: |
        # Run plan with the dynamically created variable file
        terraform plan -var-file="environments/${{ env.ENVIRONMENT }}/terraform.tfvars" -out=tfplan
        
        # Display the plan for review
        echo "\n\nTerraform Plan Output:\n"
        terraform show -no-color tfplan || echo "Plan creation failed"
    
    - name: Terraform Apply
      run: |
        terraform apply -auto-approve tfplan
